// @generated by protoc-gen-es v2.2.1 with parameter "target=ts"
// @generated from file diskuto.proto (syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file diskuto.proto.
 */
export const file_diskuto: GenFile = /*@__PURE__*/
  fileDesc("Cg1kaXNrdXRvLnByb3RvIpoBCgRJdGVtEhgKEHRpbWVzdGFtcF9tc191dGMYASABKAMSGgoSdXRjX29mZnNldF9taW51dGVzGAIgASgREhUKBHBvc3QYAyABKAsyBS5Qb3N0SAASGwoHcHJvZmlsZRgEIAEoCzIILlByb2ZpbGVIABIbCgdjb21tZW50GAUgASgLMgguQ29tbWVudEgAQgsKCWl0ZW1fdHlwZSJGCgRQb3N0Eg0KBXRpdGxlGAEgASgJEgwKBGJvZHkYAiABKAkSIQoLYXR0YWNobWVudHMYBSABKAsyDC5BdHRhY2htZW50cyKHAQoHUHJvZmlsZRIUCgxkaXNwbGF5X25hbWUYASABKAkSDQoFYWJvdXQYAiABKAkSGAoHc2VydmVycxgDIAMoCzIHLlNlcnZlchIYCgdmb2xsb3dzGAQgAygLMgcuRm9sbG93EiMKDWZvbGxvd19ncm91cHMYBSADKAsyDC5Gb2xsb3dHcm91cCI0CgdDb21tZW50EhsKCHJlcGx5X3RvGAEgASgLMgkuUmVwbHlSZWYSDAoEdGV4dBgCIAEoCSJhCghSZXBseVJlZhIYCgd1c2VyX2lkGAEgASgLMgcuVXNlcklEEh0KCXNpZ25hdHVyZRgCIAEoCzIKLlNpZ25hdHVyZRIcCglpdGVtX3R5cGUYAyABKA4yCS5JdGVtVHlwZSIVCgZTZXJ2ZXISCwoDdXJsGAEgASgJImUKBkZvbGxvdxIVCgR1c2VyGAEgASgLMgcuVXNlcklEEhQKDGRpc3BsYXlfbmFtZRgCIAEoCRIdCgxmb2xsb3dfZ3JvdXAYAyABKAVCAhgBSACIAQFCDwoNX2ZvbGxvd19ncm91cCIbCgtGb2xsb3dHcm91cBIMCgRuYW1lGAEgASgJIhcKBlVzZXJJRBINCgVieXRlcxgBIAEoDCIaCglTaWduYXR1cmUSDQoFYnl0ZXMYASABKAwiQAoISXRlbUxpc3QSHQoFaXRlbXMYASADKAsyDi5JdGVtTGlzdEVudHJ5EhUKDW5vX21vcmVfaXRlbXMYAiABKAgigAEKDUl0ZW1MaXN0RW50cnkSGAoHdXNlcl9pZBgBIAEoCzIHLlVzZXJJRBIdCglzaWduYXR1cmUYAiABKAsyCi5TaWduYXR1cmUSGAoQdGltZXN0YW1wX21zX3V0YxgDIAEoAxIcCglpdGVtX3R5cGUYBCABKA4yCS5JdGVtVHlwZSIiCgtBdHRhY2htZW50cxITCgRmaWxlGAEgAygLMgUuRmlsZSIwCgRGaWxlEgwKBGhhc2gYASABKAwSDAoEc2l6ZRgCIAEoBBIMCgRuYW1lGAMgASgJKjsKCEl0ZW1UeXBlEgsKB1VOS05PV04QABIICgRQT1NUEAESCwoHUFJPRklMRRACEgsKB0NPTU1FTlQQA2IGcHJvdG8z");

/**
 * Every piece of content that a user posts to a Diskuto server
 * (beside attachments) is an `Item`. API servers collect Items for 
 * known users, and serves them via REST requests.
 * 
 * The REST API is documented here:
 * https://github.com/diskuto/diskuto-api/tree/main/docs/rest_api
 * 
 * It's important to keep in mind that different servers may cache
 * different subsets of items.
 * 
 * Servers may (and probably should) impose a size limit for Item records.
 * Servers should accept items up to 32KiB (from users who have permission to
 * post to the server).
 * 
 *
 * @generated from message Item
 */
export type Item = Message<"Item"> & {
  /**
   * REQUIRED
   * The timestamp is used to give order to a user's collection of Items.
   * This timestamp represents the number of milliseconds since
   * 1970-01-01 00:00:00.000Z (ignoring leap seconds).
   * 
   * This is somewhat useful for displaying blog posts in order. But it's
   * especially important for ordering things like updates to a user's
   * profile.
   * 
   * As a result, servers should not accept timestamps in the future (except
   * for maybe a small allowance due to clock drift.)
   * 
   * Servers must validate that this value is specified.
   * 
   * Due to protobuf3 default values, this means the value
   * can not be exactly 0.
   * Update: With new versionf of proto3, we can now unambiguously specify 0.
   * TODO: Implement that.
   *
   * @generated from field: int64 timestamp_ms_utc = 1;
   */
  timestampMsUtc: bigint;

  /**
   * Optionally specify the user's timezone offset when they created this
   * Item. This is useful when displaying more meaningful dates on things
   * like Posts.
   * 
   * For example, Pacific Daylight Time has an offset of "-0700", or -420
   * minutes.
   * Servers should reject offsets of more than +/- 24 hours. 
   * 
   * Defaults to 0 (UTC).
   *
   * @generated from field: sint32 utc_offset_minutes = 2;
   */
  utcOffsetMinutes: number;

  /**
   * @generated from oneof Item.item_type
   */
  itemType: {
    /**
     * @generated from field: Post post = 3;
     */
    value: Post;
    case: "post";
  } | {
    /**
     * @generated from field: Profile profile = 4;
     */
    value: Profile;
    case: "profile";
  } | {
    /**
     * @generated from field: Comment comment = 5;
     */
    value: Comment;
    case: "comment";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message Item.
 * Use `create(ItemSchema)` to create a new message.
 */
export const ItemSchema: GenMessage<Item> = /*@__PURE__*/
  messageDesc(file_diskuto, 0);

/**
 * A `Post` is a typical blog post.
 *
 * @generated from message Post
 */
export type Post = Message<"Post"> & {
  /**
   * An optional plaintext title for the post.
   * Titles should be <= 256 bytes. Servers may reject longer ones.
   *
   * @generated from field: string title = 1;
   */
  title: string;

  /**
   * The body of the post, formatted in CommonMark markdown.
   * Servers should suppress unsafe raw HTML blocks in the body. They may do
   * so by rejecting the Item at the time of upload, or by choosing to render
   * the Item without the offending HTML parts.
   * 
   * The allowed size of the body is effectively limited by the allowed
   * size of the enclosing Item.
   *
   * @generated from field: string body = 2;
   */
  body: string;

  /**
   * File attachments that will be visible at ./files/*
   *
   * @generated from field: Attachments attachments = 5;
   */
  attachments?: Attachments;
};

/**
 * Describes the message Post.
 * Use `create(PostSchema)` to create a new message.
 */
export const PostSchema: GenMessage<Post> = /*@__PURE__*/
  messageDesc(file_diskuto, 1);

/**
 * A user profile, where a user can provide information about themselves.
 * 
 * The newest Profile for a user available on a server is treated as their current profile.
 * 
 * If a server serves a user profile, it must allow uploads of newer signed
 * Item entries to replace it. (This allows users to advertise new servers or,
 * eventually, revoke their profile public key.)
 *
 * @generated from message Profile
 */
export type Profile = Message<"Profile"> & {
  /**
   * A name to display instead of your userID.
   *
   * @generated from field: string display_name = 1;
   */
  displayName: string;

  /**
   * An "about me" section, formatted in Commonmark markdown.
   * Servers should suppress unsafe raw HTML blocks in the body.
   *
   * @generated from field: string about = 2;
   */
  about: string;

  /**
   * A list of servers where the user expects their content to be hosted.
   * The first server is considered the "primary" server, but others may be listed
   * as backups.
   * This allows users to move servers by updating their preferred server list.
   *
   * @generated from field: repeated Server servers = 3;
   */
  servers: Server[];

  /**
   * A list of users who this user "follows".
   * This allows the server to know what additional users it should cache data for, so that it can present this
   * (Profile) user's feed of new content.
   * 
   * The order of the list is unimportant.
   *
   * @generated from field: repeated Follow follows = 4;
   */
  follows: Follow[];

  /**
   * Users may collect their follows into groups to make sorting/filtering/syncing them easier.
   *
   * @generated from field: repeated FollowGroup follow_groups = 5;
   */
  followGroups: FollowGroup[];
};

/**
 * Describes the message Profile.
 * Use `create(ProfileSchema)` to create a new message.
 */
export const ProfileSchema: GenMessage<Profile> = /*@__PURE__*/
  messageDesc(file_diskuto, 2);

/**
 * A Comment is a text-only response to some other Item.
 *
 * @generated from message Comment
 */
export type Comment = Message<"Comment"> & {
  /**
   * Information about the Item we're replying to.
   *
   * @generated from field: ReplyRef reply_to = 1;
   */
  replyTo?: ReplyRef;

  /**
   * CommonMark markdown text. 
   * Inline images will NOT be rendered.
   *
   * @generated from field: string text = 2;
   */
  text: string;
};

/**
 * Describes the message Comment.
 * Use `create(CommentSchema)` to create a new message.
 */
export const CommentSchema: GenMessage<Comment> = /*@__PURE__*/
  messageDesc(file_diskuto, 3);

/**
 * Information about an Item that we're replying to.
 *
 * @generated from message ReplyRef
 */
export type ReplyRef = Message<"ReplyRef"> & {
  /**
   * REQUIRED: the user_id that posted the item.
   *
   * @generated from field: UserID user_id = 1;
   */
  userId?: UserID;

  /**
   * REQUIRED: the signature of the item.
   *
   * @generated from field: Signature signature = 2;
   */
  signature?: Signature;

  /**
   * Suggested: The type of the item we're replying to.
   * This is useful in case clients want to only show certain types of comments. 
   * Ex: show comments in reply to posts, but not comments replying to other comments.
   *
   * @generated from field: ItemType item_type = 3;
   */
  itemType: ItemType;
};

/**
 * Describes the message ReplyRef.
 * Use `create(ReplyRefSchema)` to create a new message.
 */
export const ReplyRefSchema: GenMessage<ReplyRef> = /*@__PURE__*/
  messageDesc(file_diskuto, 4);

/**
 * Information about where a user's posts may be found.
 * This lets content creators' clients know where to send posts when they're uploaded.
 * This also lets consumers' clients know where they can find the creator's content.
 *
 * @generated from message Server
 */
export type Server = Message<"Server"> & {
  /**
   * A URL to a FeoBlog server.
   * Ex:
   * "https://feo.example.com"
   * "https://feo.example.com/"
   * "https://feo.example.com:8080"
   * "https://feo.example.com:8080/"
   * 
   * Note 1: Subpaths are currently not supported. Ex: "https://feo.example.com/some/subpath/"
   * 
   * Note 2: While the signature authentication allows serving/sending signed protobuf Items
   * securely without HTTPS, since the main client is currently implemented as in-browser JavaScript,
   * it is recommended that servers use only HTTPS to avoid JavaScript injection in the client.
   * So, you should probably prefer https for the REST endpoints too.
   * Plus, HTTP/2 requires HTTPS, and you'll get better performance for fetching many small Items w/ HTTP/2.
   *
   * @generated from field: string url = 1;
   */
  url: string;
};

/**
 * Describes the message Server.
 * Use `create(ServerSchema)` to create a new message.
 */
export const ServerSchema: GenMessage<Server> = /*@__PURE__*/
  messageDesc(file_diskuto, 5);

/**
 * @generated from message Follow
 */
export type Follow = Message<"Follow"> & {
  /**
   * REQUIRED
   *
   * @generated from field: UserID user = 1;
   */
  user?: UserID;

  /**
   * Set a display name for a user within the context of your feed.
   * 
   * Users may change their display names in their profiles. But, unlike Twitter, FeoBlog does not have
   * a globally-unique human-readable ID to fall back on to identify someone, so it can be difficult to
   * know who's who if people keep changing their names. 
   * Here you can set a stable name so you always know who's who.
   *
   * @generated from field: string display_name = 2;
   */
  displayName: string;

  /**
   * The (0-indexed) group index that this follow should be grouped under.
   * Deprecated. see: https://github.com/diskuto/diskuto-api/issues/131
   *
   * @generated from field: optional int32 follow_group = 3 [deprecated = true];
   * @deprecated
   */
  followGroup?: number;
};

/**
 * Describes the message Follow.
 * Use `create(FollowSchema)` to create a new message.
 */
export const FollowSchema: GenMessage<Follow> = /*@__PURE__*/
  messageDesc(file_diskuto, 6);

/**
 * @generated from message FollowGroup
 */
export type FollowGroup = Message<"FollowGroup"> & {
  /**
   * A display name for this group. ex: "News", or "Friends".
   * Names should probably be unique for users' own sanity but at the moment that is not enforced by the protocol.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message FollowGroup.
 * Use `create(FollowGroupSchema)` to create a new message.
 */
export const FollowGroupSchema: GenMessage<FollowGroup> = /*@__PURE__*/
  messageDesc(file_diskuto, 7);

/**
 * @generated from message UserID
 */
export type UserID = Message<"UserID"> & {
  /**
   * A user's public NaCL key/ID. Must be 32 bytes:
   *
   * @generated from field: bytes bytes = 1;
   */
  bytes: Uint8Array;
};

/**
 * Describes the message UserID.
 * Use `create(UserIDSchema)` to create a new message.
 */
export const UserIDSchema: GenMessage<UserID> = /*@__PURE__*/
  messageDesc(file_diskuto, 8);

/**
 * @generated from message Signature
 */
export type Signature = Message<"Signature"> & {
  /**
   * A NaCL signature. Must be 64 bytes:
   *
   * @generated from field: bytes bytes = 1;
   */
  bytes: Uint8Array;
};

/**
 * Describes the message Signature.
 * Use `create(SignatureSchema)` to create a new message.
 */
export const SignatureSchema: GenMessage<Signature> = /*@__PURE__*/
  messageDesc(file_diskuto, 9);

/**
 * A list of items returned by the API server.
 * 
 * The items will usually be ordered in reverse chronological order (newest first),
 * but the order may be reversed if appropriate for some queries. (ex: find posts newer than some timestamp.)
 *
 * @generated from message ItemList
 */
export type ItemList = Message<"ItemList"> & {
  /**
   * @generated from field: repeated ItemListEntry items = 1;
   */
  items: ItemListEntry[];

  /**
   * If true, the server explicitly states there are no items after this list.
   * (i.e.: the client can stop querying)
   *
   * @generated from field: bool no_more_items = 2;
   */
  noMoreItems: boolean;
};

/**
 * Describes the message ItemList.
 * Use `create(ItemListSchema)` to create a new message.
 */
export const ItemListSchema: GenMessage<ItemList> = /*@__PURE__*/
  messageDesc(file_diskuto, 10);

/**
 * The unique ID of an item is its (user_id,signature)
 * This type encapsulates that, plus some additional metadata which 
 * can be used by clients to selectively fetch the full Item bytes from the server.
 *
 * @generated from message ItemListEntry
 */
export type ItemListEntry = Message<"ItemListEntry"> & {
  /**
   * user_id may be unspecified if it can be inferred from context.
   * (ex: in an ItemList which lists posts for a specific userID)
   *
   * @generated from field: UserID user_id = 1;
   */
  userId?: UserID;

  /**
   * REQUIRED.
   *
   * @generated from field: Signature signature = 2;
   */
  signature?: Signature;

  /**
   * REQUIRED
   * The timestamp coantained within Item.timestamp_ms_utc.
   * This is used for ordering Items, and to fetch more ItemIDs in the event
   * that this list is truncated/incomplete.   
   *
   * @generated from field: int64 timestamp_ms_utc = 3;
   */
  timestampMsUtc: bigint;

  /**
   * Specify the type of this item.
   * This allows clients to skip fetching item types they're not interested in
   * for a particular view. (ex: profile updates and/or comments, etc.)
   *
   * @generated from field: ItemType item_type = 4;
   */
  itemType: ItemType;
};

/**
 * Describes the message ItemListEntry.
 * Use `create(ItemListEntrySchema)` to create a new message.
 */
export const ItemListEntrySchema: GenMessage<ItemListEntry> = /*@__PURE__*/
  messageDesc(file_diskuto, 11);

/**
 * File attachments.
 * Certain item types may allow file attachments.
 *
 * @generated from message Attachments
 */
export type Attachments = Message<"Attachments"> & {
  /**
   * REQUIRED
   *
   * @generated from field: repeated File file = 1;
   */
  file: File[];
};

/**
 * Describes the message Attachments.
 * Use `create(AttachmentsSchema)` to create a new message.
 */
export const AttachmentsSchema: GenMessage<Attachments> = /*@__PURE__*/
  messageDesc(file_diskuto, 12);

/**
 * Metadata about a file attachment.
 * 
 * Specifying this on a Post allows you to upload this file as an attachment to that post.
 * 
 * All fields are REQUIRED.
 *
 * @generated from message File
 */
export type File = Message<"File"> & {
  /**
   * A  64-byte sha-512 hash of the contents of the file.
   *
   * @generated from field: bytes hash = 1;
   */
  hash: Uint8Array;

  /**
   * The size of the file in bytes.
   * Some servers may reject files based on their size, or the user's quota.
   * Note: The size may not be 0.
   *
   * @generated from field: uint64 size = 2;
   */
  size: bigint;

  /**
   * The name of the file.
   * The file name may not contain path separators / or \.  
   * Note: The server will use the file extension to determine the mime type with which to serve the file.
   * However, servers should take care when serving files which can pose security risks (ex: javascript).
   *
   * @generated from field: string name = 3;
   */
  name: string;
};

/**
 * Describes the message File.
 * Use `create(FileSchema)` to create a new message.
 */
export const FileSchema: GenMessage<File> = /*@__PURE__*/
  messageDesc(file_diskuto, 13);

/**
 * This is redundant with the Item.item_type oneof. But it allows us to 
 * specify the type of an item in ItemLists.
 *
 * @generated from enum ItemType
 */
export enum ItemType {
  /**
   * Default value. Either the server didn't specify the type, or
   * it was a type that the client can't deserialize.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: POST = 1;
   */
  POST = 1,

  /**
   * @generated from enum value: PROFILE = 2;
   */
  PROFILE = 2,

  /**
   * @generated from enum value: COMMENT = 3;
   */
  COMMENT = 3,
}

/**
 * Describes the enum ItemType.
 */
export const ItemTypeSchema: GenEnum<ItemType> = /*@__PURE__*/
  enumDesc(file_diskuto, 0);

